<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>RegExplainer by christopherbauer</title>
	
	<script src="scripts/jquery-1.10.2.min.js"></script>
	<script src="scripts/Context.js" type="text/javascript"></script>
	<script type="text/javascript">
			var symbol = {
				FrontSlash: '/',
				BackSlash: '\\',
				LParen: '(',
				RParen: ')',
				Dash: '-',
				LBracket: '[',
				RBracket: ']',
				Plus: '+',
				QuestionMark: '?',
				Star: '*',
				LCurled: '{',
				RCurled: '}',
				Bar: '|',
				Caret: '^',
				Dollar: '$',
				Period: '.',
			};
			$(document).ready(function() {
			
				sizeSourceInputToTextWidth();
			
				if($("#regex-source").val().length > 0) {
					execExpert();
					execHighlighter();
				}
				$("#regex-source").on("change keyup paste", function() {
					sizeSourceInputToTextWidth();
					execExpert();
					execHighlighter();
				});
				$("#regex-highlighter-example").on("change keyup paste", function() {
					execExpert();
					execHighlighter();
				});
			});
			function sizeSourceInputToTextWidth() {
				$("#regex-source").attr("size", $("#regex-source").val().length);
			}
			function execHighlighter() {
				var lines = $("#regex-highlighter-example").val().split('\n');
				var regexMinusOptions = expression.substring(expression.indexOf('/')+1,expression.lastIndexOf('/'));
				var regexp = new RegExp(regexMinusOptions);
				var highlights = [];
				for(var i = 0; i < lines.length; i++) {
					highlights[i] = {};
					highlights[i].Value = lines[i];
					highlights[i].Status = regexp.test(lines[i]);
				}
				
				var descriptions = [];
				for(var i = 0; i < highlights.length; i++) {
					$("#regex-highlighter").append($("<br/>"));
					$("#regex-highlighter").append($("<span regex-status=\""+highlights[i].Status+"\">"+highlights[i].Value + " - ["+ highlights[i].Status +"]</span>"));
				}
			}
			function execExpert(){
				reset();
				recurseExpression();
				$("#regex-description").html(expressionExplanation);
			}
			function reset() {
				expression = '/'+$("#regex-source").val()+'/'+$("#regex-options").val();
				expressionIndex = 0;
				expressionExplanation = "";
				$("#regex-highlighter").empty();
			}
			var expression;
			var expressionIndex;
			var expressionExplanation;
			var currentSymbol;
			var escaping;
			var wasChar;
			var group = 0;
			var context = new Context();
			function nextSymbol(){
				if(expressionIndex == expression.length) {
					return 0;
				}
				currentSymbol = expression[expressionIndex];
				expressionIndex++;
				return 1;
			}
			function recurseExpression() {
				nextSymbol(); //first symbol
				expect(symbol.FrontSlash);
				while(nextSymbol() && (escaping || !accept(symbol.FrontSlash))) {
					if(escaping){
						escaping = false;
						addCurrentSymbol();
					}
					else if(context.is(contexts.CharacterClass)) {
						if(accept('W')) {
							expressionExplanation += ' <span>non-word</span> '; //plan something to explain what 'non-word' is; shorthand for [^a-zA-Z_0-9]
						}
						else if(accept('W')) {
							expressionExplanation += ' <span>word</span> '; //plan something to explain what 'word' is; shorthand for [a-zA-Z_0-9]
						}
						else if(accept('s')) {
							expressionExplanation += ' <span>whitespace</span> '; //plan something to explain what 'whitespace' is; shorthand for [ \f\n\r\t\v]
						}
						else if(accept('S')) {
							expressionExplanation += ' <span>non-whitespace</span> '; //plan something to explain what 'non-whitespace' is; shorthand for [ ^\f\n\r\t\v]
						} 
						else if(accept('d')) {
							expressionExplanation += ' <span>any decimal digit</span> '; //plan something to explain; Equivalent to \p{Nd} for Unicode and [0-9] for non-Unicode
						}
						else if(accept('D')) {
							expressionExplanation += ' <span>any non-digit</span> '; //plan something to explain; Equivalent to \P{Nd} for Unicode and [^0-9] for non-Unicode
						}
						context.removeContext(contexts.CharacterClass);
					}
					else if(accept(symbol.BackSlash)) {
						if(escaping === true) {
							escaping = false;
							addCurrentSymbol();
						}
						else {
							if(lookahead('W') || lookahead('w') || lookahead('s') || lookahead('S') || lookahead('d') || lookahead('D')) {
								context.addContext(contexts.CharacterClass);
							} else {
								escaping = true;
							}
						}
					}
					else if(accept(symbol.LParen)){
						startSubExpression();
						wasChar = false;
					}
					else if(accept(symbol.RParen)){
						endSubExpression();
						wasChar = false;
					}
					else if(accept(symbol.LBracket)) {
						startCharClass();
						wasChar = false;
					}
					else if(accept(symbol.RBracket)) {
						endCharClass();
						wasChar = false;
					} 
					else if(accept(symbol.Dash)) {
						if(wasChar) {
							expressionExplanation += ' through ';
							wasChar = false;
						} else {
							addCurrentSymbol();
						}
					}
					else if(accept(symbol.Plus)) {
						expressionExplanation += ' 1 or more times ';
						wasChar = false;
					}
					else if(accept(symbol.QuestionMark)) {
						//future - lookahead for negative lookbehind assertion
						expressionExplanation += ' 0 or 1 times ';
						wasChar = false;
					}
					else if(accept(symbol.Star)) {
						expressionExplanation += ' 0 or more times ';
						wasChar = false;
					}
					else if(accept(symbol.LCurled)) {
						expressionExplanation += ' Exactly ';
						wasChar = false;
					}
					else if(accept(symbol.RCurled)) {
						expressionExplanation += ' times ';
						wasChar = false;
					}
					else if(accept(symbol.Bar)) {
						expressionExplanation += ' or ';
						wasChar = false;
					}
					else if(accept(symbol.Caret)) {
						if(context.is(contexts.ExplicitSet)) {
							expressionExplanation += ' Any character not '
						}
						else {
							var dollarPosition = ever(symbol.Dollar);
							if(dollarPosition == -1) {
								expressionExplanation += ' Starting with ';
							}
							else if(dollarPosition > expressionIndex) {
								expressionExplanation += 'Only ';
							} else {
								alwaysMatchFailure = true;
								expressionExplanation += 'Error detected';
							}
							
						}
						wasChat = false;
					}
					else if(accept(symbol.Dollar)) {
						if(ever(symbol.Caret) == -1) {
							expressionExplanation = 'Ending with ' + expressionExplanation;	
						}
					} else if(accept(symbol.Period)) {
						expressionExplanation += ' any character except <span>\\n</span> '; //explain newline
					}
					else {
						addCurrentSymbol();
					}
				}
				while(nextSymbol()) {
					if(accept('g')) {
						expressionExplanation += ' globally ';	
					}
				}
			}
			function ever(expectedSymbol) {
				for(var i = 0; i < expression.length; ++i){
					if(expression[i] == expectedSymbol) {
						return i;
					}
				}
				return -1;
			}
			function lookahead(expectedSymbol) {
				if(expressionIndex < expression.length && expression[expressionIndex] == expectedSymbol) {
					return 1;
				}
				return 0;
			}
			function addCurrentSymbol() {
				if(wasChar) {
					if(context.is(contexts.ExplicitSet)) {
						expressionExplanation += ' or ';
					}
					else if(context.is(contexts.LogicalSet)) {
						//Do nothing - should be just the characters in line
					}
				}
				expressionExplanation += currentSymbol;
				wasChar = true;
			}
			function expect(expectedSymbol) {
				if(accept(expectedSymbol)) {
					return 1;
				}
				throw new SymbolNotExpectedException(expectedSymbol);
				return 0;
			}
			function accept(symbol) {
				if(currentSymbol == symbol) {
					return 1;
				}
				return 0;
			}
			function startSubExpression(symbol) {
				expressionExplanation += '<span class="logicalGroup">(';
				context.addContext(contexts.LogicalGroup);
				group++;
			}
			function endSubExpression(symbol) {
				expressionExplanation += ')</span>';
				context.removeContext(contexts.LogicalGroup);
				group--;
			}
			function startCharClass() {
				expressionExplanation += '<span class="charSet">[';
				context.addContext(contexts.ExplicitSet);
			}
			function endCharClass() {
				expressionExplanation += ']</span>';
				context.removeContext(contexts.ExplicitSet);
			}
			function SymbolNotExpectedException(expected) {
				throw new Error("Expected '" + expected + "' but found '" + currentSymbol + "'");
			}
		</script>
		<style type="text/css">
			html {
				font-family: Lucida Console;		
			}
			input[readonly] {
				color: white;
			}
			.logicalGroup {
				background-color: cyan;
			}
			.charSet {
				background-color: yellow;
			}
			.regex-slash, #regex-options {
				display: inline;
				width: 15px;
				border: none;
				background: none;
			}
			#regex-source {
				display: inline-block;
			}
			[regex-status=false] {
				color: red;
			}
			[regex-status=true] {
				color: green;
			}
			.container {
				display: block;
			}
			#regex-highlighter-example{
				display: block;
				width: 98%;
				padding: 1%;
			}
			#regex-description {
				display: block;
				color: black;
				background-color: white;
				border: 2px dashed pink;
				padding: 3px;
				text-align: center;
				whitespace: pre-wrap;
				word-wrap: break-word;
			}
			.regex-inputs * {
				margin: 0 0 15px 0;
				font-size: 2em;
			}
		</style>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>RegExplainer</h1>
        <h2>Open source single page application that will try to describe a regex written on the site or pasted in from mysterious source code.</h2>

        <section id="downloads">
          <a href="https://github.com/christopherbauer/RegExplainer/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/christopherbauer/RegExplainer/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/christopherbauer/RegExplainer" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
		<section id="main_content">
			<div class="regex-inputs">
				<input type="text" value="/" class="regex-slash" readonly />
				<input id="regex-source" type="text" value="(ST[AR]T)|[13]" />
				<input type="text" value="/" class="regex-slash" readonly />
				<input type="text" value="g" id="regex-options" readonly />
			</div>
			<div class="container">
				<div id="regex-description"></div>
				<textarea rows="5" id="regex-highlighter-example">Hello!
123-456-7890
@1ph@-Num3r!c
STRAT
START
STAT
STRT</textarea>
			</div>
			<div id="regex-highlighter">

			</div>

		</section>

		<section id="footer">
		
		</section>		
    </div>
  </body>
</html>
		
<html>
	<head>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
		<script type="text/javascript">
			var symbol = {
				FrontSlash: '/',
				BackSlash: '\\',
				LParen: '(',
				RParen: ')',
				Dash: '-',
				LBracket: '[',
				RBracket: ']',
				Plus: '+',
				QuestionMark: '?',
				Star: '*',
				LCurled: '{',
				RCurled: '}',
				Bar: '|',
				Caret: '^',
				Dollar: '$'
			};
			$(document).ready(function() {
				if($("#regex-source").text().length > 0) {
					execExpert();
					execHighlighter();
				}
				$("#regex-source").on("change keyup paste", function() {
					execExpert();
					execHighlighter();
				});
				$("#regex-highlighter-example").on("change keyup paste", function() {
					execHighlighter();
				});
			});
			function execHighlighter() {
				var lines = $("#regex-highlighter-example").val().split('\n');
				var regexMinusOptions = $("#regex-source").val();
				regexMinusOptions = regexMinusOptions.substring(regexMinusOptions.indexOf('/')+1,regexMinusOptions.lastIndexOf('/'));
				var regexp = new RegExp(regexMinusOptions);
				var highlights = [];
				for(var i = 0; i < lines.length; i++) {
					highlights[i] = {};
					highlights[i].Value = lines[i];
					highlights[i].Status = regexp.test(lines[i]);
				}
				
				var description = "";
				for(var i = 0; i < highlights.length; i++) {
					description += highlights[i].Value + " - ["+ highlights[i].Status +"]"
				}
				$("#regex-highlighter").text(description);
			}
			function execExpert(){
				reset();
				recurseExpression();
				$("#regex-description").html(expressionExplanation);
			}
			function reset() {
				expression = $("#regex-source").val();
				expressionIndex = 0;
				expressionExplanation = "";
			}
			var expression;
			var expressionIndex;
			var expressionExplanation;
			var currentSymbol;
			var escaping;
			var wasChar;
			var group = 0;
			function nextSymbol(){
				if(expressionIndex == expression.length) {
					return 0;
				}
				currentSymbol = expression[expressionIndex];
				expressionIndex++;
				return 1;
			}
			function recurseExpression(expression) {
				nextSymbol(); //first symbol
				expect(symbol.FrontSlash);
				while(nextSymbol() && (escaping || !accept(symbol.FrontSlash))) {
					if(escaping){
						escaping = false;
						addCurrentSymbol();
					}
					else if(accept(symbol.BackSlash)) {
						if(escaping === true) {
							escaping = false;
							addCurrentSymbol();
						} else {
							escaping = true;
						}
					}
					else if(accept(symbol.LParen)){
						startSubExpression();
						wasChar = false;
					}
					else if(accept(symbol.RParen)){
						endSubExpression();
						wasChar = false;
					}
					else if(accept(symbol.LBracket)) {
						startCharClass();
						wasChar = false;
					}
					else if(accept(symbol.RBracket)) {
						endCharClass();
						wasChar = false;
					} 
					else if(accept(symbol.Dash)) {
						expressionExplanation += ' through ';
						wasChar = false;
					}
					else if(accept(symbol.Plus)) {
						expressionExplanation += ' 1 or more times ';
						wasChar = false;
					}
					else if(accept(symbol.QuestionMark)) {
						//future - lookahead for negative lookbehind assertion
						expressionExplanation += ' 0 or 1 times ';
						wasChar = false;
					}
					else if(accept(symbol.Star)) {
						expressionExplanation += ' 0 or more times ';
						wasChar = false;
					}
					else if(accept(symbol.LCurled)) {
						expressionExplanation += ' Exactly ';
						wasChar = false;
					}
					else if(accept(symbol.RCurled)) {
						expressionExplanation += ' times ';
						wasChar = false;
					}
					else if(accept(symbol.Bar)) {
						expressionExplanation += ' or ';
						wasChar = false;
					}
					else if(accept(symbol.Caret)) {
						expressionExplanation += ' Starting with ';
						wasChat = false;
					}
					else if(accept(symbol.Dollar)) {
						expressionExplanation += ' Ending with preceding ';
					}
					else {
						addCurrentSymbol();
					}
				}
				while(nextSymbol()) {
					if(accept('g')) {
						expressionExplanation += ' globally ';
					}
				}
			}
			function lookahead(expectedSymbol) {
				if(expressionIndex < expression.length && expression[expressionIndex] == expectedSymbol) {
					return 1;
				}
				return 0;
			}
			function addCurrentSymbol() {
				if(group > 0 && wasChar) {
					expressionExplanation += ' and ';
				}
				else if(wasChar) {
					expressionExplanation += ' or ';
				}
				expressionExplanation += ' ' + currentSymbol + ' ';
				wasChar = true;
			}
			function expect(expectedSymbol) {
				if(accept(expectedSymbol)) {
					return 1;
				}
				throw new SymbolNotExpectedException(expectedSymbol);
				return 0;
			}
			function accept(symbol) {
				if(currentSymbol == symbol) {
					return 1;
				}
				return 0;
			}
			function startSubExpression(symbol) {
				expressionExplanation += '<span class="logicalGroup">(Group: ';
				group++;
			}
			function endSubExpression(symbol) {
				expressionExplanation += ')</span>';
				group--;
			}
			function startCharClass() {
				expressionExplanation += '<span class="charSet">[Char Set: ';
			}
			function endCharClass() {
				expressionExplanation += ']</span>';
			}
			function SymbolNotExpectedException(expected) {
				throw new Error("Expected '" + expected + "' but found '" + currentSymbol + "'");
			}
		</script>
		<style type="text/css">
			.logicalGroup {
				background-color: cyan;
			}
			.charSet {
				background-color: yellow;
			}
		</style>
	</head>
	<body>
		<section id="head">
			<h2>RegExpert</h2>
			<em>An engine for describing regex as you type it!</em>
		</section>
		<section id="content">
			<textarea rows="3" cols="120" id="regex-source">/[A-Z\.]+[a-z+(abc)?]*(abc){2}/g</textarea>
			<div id="regex-description"></div>
			<textarea rows="5" cols="120" id="regex-highlighter-example">Hello!
123-456-7890
@1ph@-Num3r!c</textarea>
			<div id="regex-highlighter">
			
			</div>
		</section>
		<section id="footer">
		
		</section>
	</body>
</html>
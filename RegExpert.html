<html>
	<head>
		<script src="jquery-1.10.2.min.js"></script>
		<script src="Context.js" type="text/javascript"></script>
		<script type="text/javascript">
			var symbol = {
				FrontSlash: '/',
				BackSlash: '\\',
				LParen: '(',
				RParen: ')',
				Dash: '-',
				LBracket: '[',
				RBracket: ']',
				Plus: '+',
				QuestionMark: '?',
				Star: '*',
				LCurled: '{',
				RCurled: '}',
				Bar: '|',
				Caret: '^',
				Dollar: '$',
				Period: '.',
			};
			$(document).ready(function() {
			
				sizeSourceInputToTextWidth();
			
				if($("#regex-source").val().length > 0) {
					execExpert();
					execHighlighter();
				}
				$("#regex-source").on("change keyup paste", function() {
					sizeSourceInputToTextWidth();
					execExpert();
					execHighlighter();
				});
				$("#regex-highlighter-example").on("change keyup paste", function() {
					execExpert();
					execHighlighter();
				});
			});
			function sizeSourceInputToTextWidth() {
				$("#regex-source").attr("size", $("#regex-source").val().length);
			}
			function execHighlighter() {
				var lines = $("#regex-highlighter-example").val().split('\n');
				var regexMinusOptions = expression.substring(expression.indexOf('/')+1,expression.lastIndexOf('/'));
				var regexp = new RegExp(regexMinusOptions);
				var highlights = [];
				for(var i = 0; i < lines.length; i++) {
					highlights[i] = {};
					highlights[i].Value = lines[i];
					highlights[i].Status = regexp.test(lines[i]);
				}
				
				var descriptions = [];
				for(var i = 0; i < highlights.length; i++) {
					$("#regex-highlighter").append($("<br/>"));
					$("#regex-highlighter").append($("<span regex-status=\""+highlights[i].Status+"\">"+highlights[i].Value + " - ["+ highlights[i].Status +"]</span>"));
				}
			}
			function execExpert(){
				reset();
				recurseExpression();
				$("#regex-description").html(expressionExplanation);
			}
			function reset() {
				expression = '/'+$("#regex-source").val()+'/'+$("#regex-options").val();
				expressionIndex = 0;
				expressionExplanation = "";
				$("#regex-highlighter").empty();
			}
			var expression;
			var expressionIndex;
			var expressionExplanation;
			var currentSymbol;
			var escaping;
			var wasChar;
			var group = 0;
			var context = new Context();
			function nextSymbol(){
				if(expressionIndex == expression.length) {
					return 0;
				}
				currentSymbol = expression[expressionIndex];
				expressionIndex++;
				return 1;
			}
			function recurseExpression() {
				nextSymbol(); //first symbol
				expect(symbol.FrontSlash);
				while(nextSymbol() && (escaping || !accept(symbol.FrontSlash))) {
					if(escaping){
						escaping = false;
						addCurrentSymbol();
					}
					else if(context.is(contexts.CharacterClass)) {
						if(accept('W')) {
							expressionExplanation += ' <span>non-word</span> '; //plan something to explain what 'non-word' is; shorthand for [^a-zA-Z_0-9]
						}
						else if(accept('W')) {
							expressionExplanation += ' <span>word</span> '; //plan something to explain what 'word' is; shorthand for [a-zA-Z_0-9]
						}
						else if(accept('s')) {
							expressionExplanation += ' <span>whitespace</span> '; //plan something to explain what 'whitespace' is; shorthand for [ \f\n\r\t\v]
						}
						else if(accept('S')) {
							expressionExplanation += ' <span>non-whitespace</span> '; //plan something to explain what 'non-whitespace' is; shorthand for [ ^\f\n\r\t\v]
						} 
						else if(accept('d')) {
							expressionExplanation += ' <span>any decimal digit</span> '; //plan something to explain; Equivalent to \p{Nd} for Unicode and [0-9] for non-Unicode
						}
						else if(accept('D')) {
							expressionExplanation += ' <span>any non-digit</span> '; //plan something to explain; Equivalent to \P{Nd} for Unicode and [^0-9] for non-Unicode
						}
						context.removeContext(contexts.CharacterClass);
					}
					else if(accept(symbol.BackSlash)) {
						if(escaping === true) {
							escaping = false;
							addCurrentSymbol();
						}
						else {
							if(lookahead('W') || lookahead('w') || lookahead('s') || lookahead('S') || lookahead('d') || lookahead('D')) {
								context.addContext(contexts.CharacterClass);
							} else {
								escaping = true;
							}
						}
					}
					else if(accept(symbol.LParen)){
						startSubExpression();
						wasChar = false;
					}
					else if(accept(symbol.RParen)){
						endSubExpression();
						wasChar = false;
					}
					else if(accept(symbol.LBracket)) {
						startCharClass();
						wasChar = false;
					}
					else if(accept(symbol.RBracket)) {
						endCharClass();
						wasChar = false;
					} 
					else if(accept(symbol.Dash)) {
						if(wasChar) {
							expressionExplanation += ' through ';
							wasChar = false;
						} else {
							addCurrentSymbol();
						}
					}
					else if(accept(symbol.Plus)) {
						expressionExplanation += ' 1 or more times ';
						wasChar = false;
					}
					else if(accept(symbol.QuestionMark)) {
						//future - lookahead for negative lookbehind assertion
						expressionExplanation += ' 0 or 1 times ';
						wasChar = false;
					}
					else if(accept(symbol.Star)) {
						expressionExplanation += ' 0 or more times ';
						wasChar = false;
					}
					else if(accept(symbol.LCurled)) {
						expressionExplanation += ' Exactly ';
						wasChar = false;
					}
					else if(accept(symbol.RCurled)) {
						expressionExplanation += ' times ';
						wasChar = false;
					}
					else if(accept(symbol.Bar)) {
						expressionExplanation += ' or ';
						wasChar = false;
					}
					else if(accept(symbol.Caret)) {
						if(context.is(contexts.ExplicitSet)) {
							expressionExplanation += ' Any character not '
						}
						else {
							expressionExplanation += ' Starting with ';
						}
						wasChat = false;
					}
					else if(accept(symbol.Dollar)) {
						expressionExplanation += ' Ending with preceding ';
					} else if(accept(symbol.Period)) {
						expressionExplanation += ' any character except <span>\\n</span> '; //explain newline
					}
					else {
						addCurrentSymbol();
					}
				}
				while(nextSymbol()) {
					if(accept('g')) {
						expressionExplanation += ' globally ';
					}
				}
			}
			function lookahead(expectedSymbol) {
				if(expressionIndex < expression.length && expression[expressionIndex] == expectedSymbol) {
					return 1;
				}
				return 0;
			}
			function addCurrentSymbol() {
				if(wasChar) {
					if(context.is(contexts.ExplicitSet)) {
						expressionExplanation += ' or ';
					}
					else if(context.is(contexts.LogicalSet)) {
						//Do nothing - should be just the characters in line
					}
				}
				expressionExplanation += currentSymbol;
				wasChar = true;
			}
			function expect(expectedSymbol) {
				if(accept(expectedSymbol)) {
					return 1;
				}
				throw new SymbolNotExpectedException(expectedSymbol);
				return 0;
			}
			function accept(symbol) {
				if(currentSymbol == symbol) {
					return 1;
				}
				return 0;
			}
			function startSubExpression(symbol) {
				expressionExplanation += '<span class="logicalGroup">(';
				context.addContext(contexts.LogicalGroup);
				group++;
			}
			function endSubExpression(symbol) {
				expressionExplanation += ')</span>';
				context.removeContext(contexts.LogicalGroup);
				group--;
			}
			function startCharClass() {
				expressionExplanation += '<span class="charSet">[Char Set: ';
				context.addContext(contexts.ExplicitSet);
			}
			function endCharClass() {
				expressionExplanation += ']</span>';
				context.removeContext(contexts.ExplicitSet);
			}
			function SymbolNotExpectedException(expected) {
				throw new Error("Expected '" + expected + "' but found '" + currentSymbol + "'");
			}
		</script>
		<style type="text/css">
			.logicalGroup {
				background-color: cyan;
			}
			.charSet {
				background-color: yellow;
			}
			.regex-slash, #regex-options {
				display: inline;
				width: 15px;
				border: none;
				background: none;
			}
			#regex-source {
				display: inline-block;
			}
			[regex-status=false] {
				color: red;
			}
			[regex-status=true] {
				color: green;
			}
		</style>
	</head>
	<body>
		<section id="head">
			<h2>RegExpert</h2>
			<em>An engine for describing regex as you type it!</em>
		</section>
		<section id="content">
			<input type="text" value="/" class="regex-slash" readonly />
			<input id="regex-source" type="text" value="(ST[AR]T)|[13]" />
			<input type="text" value="/" class="regex-slash" readonly />
			<input type="text" value="g" id="regex-options" readonly />
			<div id="regex-description"></div>
			<textarea rows="5" cols="120" id="regex-highlighter-example">Hello!
123-456-7890
@1ph@-Num3r!c
STRAT
START
STAT
STRT</textarea>
			<div id="regex-highlighter">
			
			</div>
		</section>
		<section id="footer">
		
		</section>
	</body>
</html>